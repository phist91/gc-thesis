%!TEX root = ../thesis.tex
\chapter{Fazit}
\label{cha:fazit}

In dieser Arbeit wurden auf der Grundlage eines abstrakten Speichermodells verschiedene Garbage-Collection-Algorithmen zur automatischen Speicherverwaltung aufgearbeitet und analysiert.
Mit dem Mark-Sweep-Algorithmus und der Referenzzählung haben wir zwei anfangs sehr unterschiedliche Ansätze kennengelernt, welche die Freigabe nicht mehr benötigten Speichers bewerkstelligen.
Durch einige Optimierungen war zu sehen, dass diese scheinbar konträren Ansätze keineswegs unvereinbar sind:
Zusätzliche Kollektionsphasen neben der Referenzzählung erleichtern den Umgang mit zyklischen Strukturen und lindern gleichzeitig den Performanceverlust, der mit einer rigorosen Nachverfolgung von Referenzmanipulationen einhergeht.
Mit der verborgenen Referenzzählung konnten wir schließlich sehen, dass eine Vereinigung beider Grundverfahren eine vielversprechende Lösung darstellt, um \textit{das Beste zweier Welten} zu kombinieren.
Eine wesentliche Rolle spielt dabei auch der zuvor betrachtete Halbraumalgorithmus von \textsc{Fenichel}, \textsc{Yochelson} und \textsc{Cheney}, der das zentrale Problem der Speicherfragmentierung durch eine Kompaktierung des Heaps behebt, sowie die Partitionierung des Heaps in disjunkte Speicherbereiche.

Der im zweiten Teil entworfene Garbage-Collection-Simulator ist in der Lage, vorgestellte Algorithmen ansprechend zu visualisieren.
Die angebotenen Konfigurationsmöglichkeiten gestatten dabei, verschiedene Anwendungsfälle zu simulieren und interessante Eigenschaften der implementierten Algorithmen zu entdecken.
Durch eine geschickte Modellierung ist zudem eine Ergänzung um weitere Allokations- und Kollektionsverfahren zwecks ihrer Visualisierung und Erprobung möglich.
Einziger Wermutstropfen ist jedoch die fehlende Darstellung von Referenzen, wodurch eine Simulation von referenzzählenden Verfahren eher erkenntnisarm sein dürfte.
Als Abhilfe ist eine zusätzliche Darstellung des Objektgraphen denkbar, sodass die Verwaisung von Objekten und die Anpassung von Referenzen in kompaktierenden Algorithmen direkt beobachtet werden kann.
Diesbezüglich kann auch eine Erhöhung der Interaktivität in Betracht gezogen werden, indem die Anwenderin mithilfe des Objektgraphen selbst die Vernetzung und Verwaisung der Objekte bestimmt.
Somit können verschiedene Algorithmen gezielt an festen Beispielszenarien erprobt werden, was mit der ausschließlich auf Wahrscheinlichkeiten basierenden Implementation aktuell nicht möglich ist.
Eine weitere mögliche Ergänzung ist die Integration eines \textit{Steppers}, mit dem die Anwenderin selbst den nächsten Arbeitsschritt eines Kollektors auslöst.
Die verwendeten Swing-Timer bieten hierfür eine gute Grundlage, da sie auch einen Modus besitzen, in dem jede Ausführung manuell ausgelöst werden kann.

Schlussendlich muss beachtet werden, dass die vorliegende Arbeit maximal einen Überblick über zentrale Algorithmen und Ansätze bieten kann.
Allein die von Richard \textsc{Jones} gepflegte \textit{Garbage Collection Bibliography}\footnote{\url{https://www.cs.kent.ac.uk/people/staff/rej/gcbib/gcbib.pdf}} zählt über 2.500 Publikationen zum Thema Garbage Collection.
Darunter sind zahlreiche zu finden, die sich auf spezielle Anwendungsfälle beziehen oder Schwerpunkte wie Nebenläufigkeit, Parallelisierung und Echtzeitsysteme betonen.
Auch, wenn diese Konzepte nicht im Detail betrachtet wurden, bietet diese Arbeit eine gute Einführung in die zugrunde liegende Thematik, sodass sie durchaus als Vorbereitung zur Auseinandersetzung mit elaborierteren Garbage-Collection-Algorithmen verstanden werden kann.
Darüber hinaus liefert sie Hinweise auf relevante Aspekte, die für die Entscheidungsfindung für oder gegen einen Garbage-Collection-Algorithmus beachtet werden sollten.
Dies spielt vor allem für Systeme und Programmiersprachen wie \textit{Java} eine Rolle, bei denen die Entwicklerin aus verschiedenen vorimplementierten Algorithmen wählen kann.\footnote{Siehe beispielsweise hier für die \textit{Oracle Java HotSpot Virtual Machine}: \url{https://docs.oracle.com/en/java/javase/11/gctuning/available-collectors.html}}
Mit dem Aufkommen neuer Anwendungsfälle entsteht auch der Bedarf an hochperformanten und ressourceneffizienten Algorithmen zur automatischen Speicherverwaltung, die an die jeweilige Situation angepasst sind.
Insofern lässt sich abschließend festhalten, dass die Thematik der Garbage-Collection-Algorithmen auch in Zukunft von hoher Relevanz ist.
