%!TEX root = ../../thesis.tex
\chapter{Referenzzählung}
\label{cha:reference-counting}
Der zweite Garbage-Collection-Algorithmus, der in dieser Arbeit vorgestellt wird, stammt von George Collins und aus dem selben Jahr wie der Mark-Sweep-Algorithmus.
Collins betrachtet wie McCarthy das \textit{LISP Programming System} auf IBM-Großrechnern und das Problem, wann Listenelemente, die prinzipiell in mehreren Listen vorkommen können, wieder freigegeben werden dürfen.
McCarthys Ansatz bezeichnet er jedoch als \enquote{elegant but inefficient} \cite[S. 655]{collins1960}, da dieser sowohl zeitaufwändig sei als auch den Speicherplatz für Nutzdaten einschränke.
Stattdessen schlägt Collins vor, zusätzlich zu einem Datum die Anzahl der Referenzen auf dieses zu speichern.
Anhand dieses Zählers, der bei der Manipulation von Referenzen aktualisiert wird, kann unmittelbar festgestellt werden, ob ein Datum verwaist ist und der entsprechende Speicherplatz freigegeben werden kann \cite[S. 656f]{collins1960}.
Diesen Ansatz -- die \textit{Referenzzählung} (engl. \textit{reference counting}) -- werden wir in diesem Kapitel ausführlich betrachten.

\section{Naive Referenzzählung}
\label{sec:naive-rc}
Zur Realisierung des Algorithmus von Collins in unserem Speichermodell nutzen wir erneut den Header eines Objekts \Var{a}, um dort einen ganzzahligen, nicht negativen Wert \Var{rc}(\Var{a}) zu hinterlegen, den wir als \textit{Referenzzähler} bezeichnen.
Dieser gibt an, wie viele Referenzen von anderen Objekten auf \Var{a} existieren, und wird bei der Erzeugung von \Var{a} mit dem Wert $0$ initialisiert.
Auf diese Art erhalten wir unmittelbar eine notwendige Bedingung für die Erreichbarkeit eines Objekts:
Ist $\Var{a} \in \Reach$, so existiert mindestens ein Objekt $\Var{b} \neq \Var{a}$ mit $\Var{b} \rightarrow \Var{a}$ und somit gilt $\Var{rc}(\Var{a}) \geq 1$.

\begin{mybox}
\begin{lemma}[Notwendige Bedingung für Erreichbarkeit]
\label{lemma:notwendig-rc}
	Für ein Objekt $\Var{a}$ gilt: Ist $\Var{a} \in \Reach$, so folgt $\Var{rc}(\Var{a}) \geq 1$.
\end{lemma}
\end{mybox}

Diese Bedingung ist allerdings nicht hinreichend, da die Objekte, von denen die Referenzen ausgehen, gegebenenfalls nicht erreichbar sind und die Erreichbarkeit von \Var{a} somit nicht garantiert werden kann.
Jedoch folgt als Kontraposition von Lemma~\ref{lemma:notwendig-rc} sofort, dass ein Objekt $\Var{a}$ mit $\Var{rc}(\Var{a}) = 0$ nicht erreichbar ist und freigegeben werden kann.

Wie kann \Var{rc}(\Var{a}) nun verwendet werden, um automatisch ein nicht erreichbares Objekt freizugeben?
Immer, wenn eine Referenz auf \Var{a} in ein Feld eines anderen Objekts geschrieben wird, so muss \Var{rc}(\Var{a}) inkrementiert werden.
Gleichzeitig muss der Referenzzähler des Objekts \Var{b}, welches das Ziel der überschriebenen Referenz war, dekrementiert werden.
Wenn dieser anschließend den Wert $0$ aufweist, kann \Var{b} sofort freigegeben werden.
Diese Manipulationen der Referenzzähler sind unmittelbar auszuführen, nachdem eine Referenz manipuliert wurde.
Daher bieten sich zur Realisierung Schreibbarrieren an, die bereits in Abschnitt~\ref{sec:tricolor} eingeführt wurden.

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\Input Objekt \Var{obj}, in dem Referenz gesetzt wird; Index des Feldes \Var{i}; zu setzende Referenz \Var{ref}
	\State \Atomic \MethodHead{writeRef}(\Var{obj}, \Var{i}, \Var{ref}):
	\State \quad \IF (\Var{ref} $\neq$ \Null $\wedge$ \Var{*ref} $\neq$ \Var{obj})	\Comment{Erhöhe \Var{rc}, falls nicht \Null oder}
	\State \quad \quad $\Var{rc}(\Var{*ref}) \gets \Var{rc}(\Var{*ref}) + 1$ \Comment{Selbstreferenz geschrieben wird}
	\State \quad \IF (\Var{obj[i]} $\neq$ \Null $\wedge$ \Var{*obj[i]} $\neq$ \Var{obj})	\Comment{Reduziere \Var{rc}, falls nicht \Null oder}
	\State \quad \quad \Method{decRefCount}(\Var{*obj[i]})	\Comment{Selbstreferenz überschrieben wird}
	\State \quad \Var{obj[i]} $\gets$ \Var{ref}
	\Statex
	\State \MethodHead{decRefCount}(\Var{obj}):
	\State \quad $\Var{rc}(\Var{obj}) \gets \Var{rc}(\Var{obj}) - 1$
	\State \quad \IF $\Var{rc}(\Var{obj}) = 0$
	\State \quad \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \quad \IF (\Var{ref} $\neq$ \Null $\wedge$ \Var{*ref} $\neq$ \Var{obj}) \Comment{Reduziere rekursiv \Var{rc}}
	\State \quad \quad \quad \quad \Method{decRefCount}(\Var{*ref}) \Comment{referenzierter Objekte}
	\State \quad \quad \Method{free}(\Var{\&obj})
\end{algorithmic}
\caption[Naive Referenzzählung]{Naive Referenzzählung mittels Schreibbarriere (vgl. \cite[S. 58]{handbook}).}
\label{algo:naive-rc}
\end{algorithm}

Die in Algorithmus~\ref{algo:naive-rc} aufgeführte Schreibbarriere kommt genau dann zum Einsatz, wenn mittels $\Var{obj}[i] \gets \Var{ref}$ in ein Feld eines Objekts eine Referenz geschrieben wird.
Dabei wird zunächst geprüft, ob eine Selbstreferenz oder \Null geschrieben werden soll (Zeile 2f).
In beiden Fällen ist der Referenzzähler des Ziels nicht zu erhöhen, da die Operation die Erreichbarkeit des Ziels nicht beeinflusst.
Analog wird überprüft, ob im betroffenen Feld bereits eine Referenz auf ein anderes Objekt gespeichert ist (Zeile 4f).
Wenn ja, muss dessen Referenzzähler entsprechend dekrementiert werden.
Im Anschluss kann die neue Referenz in das Feld des Objekts geschrieben werden.

Das Herabsetzen des Referenzzählers wird durch die Prozedur \Method{decRefCount} übernommen.
Dabei wird zugleich geprüft, ob dieser anschließend $0$ ist (Zeile 9).
In diesem Fall wird das entsprechende Objekt \Var{obj} freigegeben.
Die Freigabe führt allerdings dazu, dass auch die Zähler derjenigen Objekte verringert werden müssen, die von \Var{obj} referenziert werden.
Ensprechend wird für jede Referenz in den Feldern von \Var{obj}, die nicht \Null oder eine Selbstreferenz ist, \Method{decRefCount} rekursiv aufgerufen (Zeile 10 bis 12).

\todo[inline]{Beispiel}

Die Atomizität der Schreibbarriere verhindert die Entstehung von \textit{race conditions} bei gleichzeitigen Zugriffen auf Referenzzähler und ist daher unabdingbar.
Ebenso ist es wesentlich, dass der Referenzzähler des neuen Ziels zunächst inkrementiert wird, bevor der des alten Ziels dekrementiert wird.
Andernfalls könnte es, wenn altes und neues Ziel identisch sind, passieren, dass der Zähler auf $0$ reduziert würde.
In der Folge würde das Ziel sofort freigegeben werden, obwohl es weiterhin erreichbar bliebe.

\begin{mybox}
\begin{satz}[]
\label{satz:rc-correctness}
	Der Algorithmus~\ref{algo:naive-rc} zur Referenzzählung ist korrekt und terminiert.
\end{satz}
\end{mybox}

\begin{proof}
	Zu zeigen ist zunächst, dass die rekursiven Aufrufe von \Method{decRefCount} in Zeile 12 terminieren.
	Angenommen, es gäbe eine nicht terminierende Folge von Aufrufen $\Method{decRefCount}(\Var{a}_1), \Method{decRefCount}(\Var{a}_2), \dots$
	für Objekte $\Var{a}_i, i \in \NN$.
	Da jedes Objekt nur endlich viele Referenzen auf andere Objekte besitzt, ist $\Pointers(\Var{a}_i)$ endlich für alle $i \in \NN$.
	Weiter ist die Anzahl aller Objekte endlich; es muss also ein Objekt $\Var{a}_j$ existieren, für welches $\Method{decRefCount}(\Var{a}_j)$ unendlich oft aufgerufen wird.
	Allerdings wird $\Method{decRefCount}(\Var{a}_j)$ nur aufgerufen, wenn ein Objekt $\Var{b}$ mit $\Var{b} \rightarrow \Var{a}_j$ existiert, für welches zuvor $\Var{rc}(\Var{b})$ auf $0$ gesetzt wurde.
	Da während der rekursiven Aufrufe von \Method{decRefCount} keine Referenzzähler erhöht werden, müssen also unendlich viele verschiedene Objekte \Var{b} mit dieser Eigenschaft existieren.
	Das ist jedoch ein Widerspruch zur Endlichkeit der Anzahl aller Objekte.
	
	Es bleibt zu zeigen, dass der Algorithmus korrekt ist.
	Die Freigabe eines Objekts \Var{a} durch den Algorithmus erfolgt ausschließlich in Zeile 13.
	Diese wird nur ausgelöst, wenn $\Var{rc}(\Var{a}) = 0$ gilt.
	Aus Lemma~\ref{lemma:notwendig-rc} folgt, dass \Var{a} nicht erreichbar ist.
\end{proof}

Die Garbage Collection mithilfe naive Referenzzählung bietet im Vergleich zum Mark-Sweep-Algorithmus einige Vorteile, aber auch gewisse Nachteile (vgl. \cite[S. 346]{linhou2006}):
Der Mechanismus zur Freigabe von Objekten wird durch die Entstehung von verwaisten Objekten ausgelöst und nicht etwa, wenn unzureichend freier Speicher zu Verfügung steht.
Dadurch wird die Allokation von Speicher für neu erzeugte Objekte nicht verzögert.
Verwaiste Objekte werden beim Löschen ihrer letzten Referenz unmittelbar erkannt und freigegeben und nicht erst beim nächsten Mark-Sweep-Zyklus.
Speichermangel kann de facto nur dadurch entstehen, dass der gesamte Speicher von erreichbaren Objekten belegt wird -- in diesem Fall bietet allerdings kein Garbage-Collection-Algorithmus Abhilfe.
Referenzzählung benötigt zudem keinen Zugriff auf den vollständigen Objektgraphen:
Da kein Aufspüren aller erreichbaren Objekte durchgeführt wird, kann auf eine Traversierung des Objektgraphen verzichtet werden.
Dies ist besonders für verteilte Systeme von Vorteil, in denen die Markierungsphase sonst mehrere Knoten des Systems belasten und erhöhten Datenaustausch zwischen diesen verursachen würde.
Weiter lässt sich erahnen, dass Referenzzählung weniger stark dazu neigt, Cache-Mechanismen zu beeinträchtigen.
Im Gegensatz zu Mark and Sweep finden kaum unvorhersehbare Objektzugriffe statt.
Wird der Referenzzähler eines Objektes erhöht, so wird gerade eine neue Referenz hierauf angelegt.
Die Wahrscheinlichkeit, dass im Programmablauf kurz danach auch ein Zugriff auf dieses Objekt vorgesehen ist, ist daher relativ hoch.
Zeitliche Lokalität ist somit gegeben.

Trotz dieser Vorteile ist die naive Referenzzählung jedoch kein Allheilmittel.
Dadurch, dass bei jeglicher Referenzänderung eine Manipulation der Zähler erfolgt, werden Operationen des Mutators, die ursprünglich nur lesend auf Objekte zugreifen, zu Schreibzugriffen.
Diese Problematik wird in Verbindung mit dynamischen Datenstrukturen besonders deutlich:
Betrachten wir etwa die lineare Suche auf einer einfach verketteten Liste, so fällt auf, dass bei jeder Iteration die Referenzvariable auf das aktuell betrachtete Element neu gesetzt wird (Zeile 4 in Algorithmus~\ref{algo:linsearch}).
Dadurch werden zwei Schreibzugriffe notwendig, die die Zähler des zuletzt betrachteten Objekts reduzieren und des nächsten Objekts erhöhen, obwohl deren Erreichbarkeit tatsächlich nicht beeinflusst wird.
Die Anzahl an Speicheroperationen wird also signifikant vergrößert.
Durch den rekursiven Aufruf von \Method{decRefCount} kann es zudem zu einer Kaskade an Freigaben und Zählermanipulationen kommen, sobald ein Objekt freigegeben wird.
In Verbindung mit der Atomizität der Schreibbarriere können dadurch größere und unerwartete Verzögerungen im Programmablauf entstehen, die bei zeitkritischen Anwendungen um jeden Preis zu vermeiden sind.

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\State \MethodHead{linSearch}(\Var{list}, \Var{x}):
	\State \quad \Var{cur} $\gets$ \Method{first}(\Var{list})
	\State \quad \WHILE $(\Var{cur} \neq \Null \wedge \Var{*cur} \neq \Var{x})$
	\State \quad \quad \Var{cur} $\gets$ \Method{next}(\Var{list})
	\State \quad \Return \Var{cur} 
\end{algorithmic}
\caption[Lineare Suche]{Lineare Suche in einer verketteten Liste. Obwohl der Algorithmus keine Objekte manipuliert, verursacht jede Änderung an der Referenzvariablen \Var{cur} die Manipulation von zwei Referenzzählern.}
\label{algo:linsearch}
\end{algorithm}

Ein weiteres Problem entsteht, wenn zyklische Datenstrukturen wie etwa doppelt verkettete Listen verwendet werden.
Die gesamte Struktur kann unerreichbar sein, obwohl die Referenzzähler der einzelnen Objekte nicht $0$ sind (siehe Abbildung~\ref{fig:rc-cycle}).
Die einzelnen Objekte werden dann nicht als löschbar erkannt, was zu einem Speicherleck führt.
Eine mögliche Lösung dieser Problematik wird im nächsten Abschnitt betrachtet.
Im Anschluss daran werden weitere Ansätze vorgestellt, die eine Effizienzsteigerung der naiven Referenzzählung anstreben. \todo[inline]{Ausblick auf nächste Abschnitte}

\begin{figure}[h]
	\centering
	\includestandalone{img/tikz/ch3-cycle}
	\caption[Referenzzählung in zyklischen Datenstrukturen]{Referenzzählung in zyklischen Datenstrukturen. Wird Objekt \Var{L} entfernt, sind \Var{a} und \Var{b} nicht mehr erreichbar. Jedoch fallen ihre Referenzzähler nicht auf $0$, sodass sie als Speicherlecks im Speicher verbleiben.}
	\label{fig:rc-cycle}
\end{figure}

\section{Zyklische Referenzen}
\label{sec:cyclic-rc}
Die fehlende Möglichkeit zur Erkennung und Freigabe zyklischer Strukturen kann -- bei entsprechend häufiger Verwendung -- große Teile des Heaps brachliegen lassen.
Ein gelegentlich zusätzlich ausgeführter Mark-Sweep-Zyklus mag diese Problematik zwar beheben, macht allerdings die oben genannten Vorteile der Referenzzählung zunichte.
Nachfolgend stellen wir einen Algorithmus von Martínez et al. vor, der die naive Referenzählung um ein Verfahren ergänzt, mit welchem zyklische Strukturen zuverlässig erkannt werden können \cite{martinez1990}.
Dieses basiert darauf, dass ein Zyklus von Objekten als starke Zusammenhangskomponente im Objektgraphen aufgefasst werden kann (vgl. \cite[S. 348]{linhou2006}).
Das bedeutet, dass von jedem Objekt aus jedes andere Objekt innerhalb des Zyklus erreicht werden kann.
Passt man die Referenzzähler jedes Objekts so an, dass \textbf{interne Referenzen} -- das sind Referenzen zwischen zwei Objekten, die sich innerhalb des Zyklus befinden -- unberücksichtigt bleiben, geben diese anschließend Auskunft darüber, wie viele \textbf{externe Referenzen} von Objekten außerhalb der Struktur auf Objekte innerhalb des Zyklus existieren.
Besitzen alle so modifierten Zähler der Struktur den Wert $0$, so ist der Zyklus nicht mehr erreichbar und kann entfernt werden.
Anders formuliert: Besitzt die Struktur ein Objekt, das über eine externe Referenz erreichbar ist, so ist die gesamte Struktur von außen erreichbar.

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\State \MethodHead{decRefCount}(\Var{obj}):
	\State \quad $\Var{rc}(\Var{obj}) \gets \Var{rc}(\Var{obj}) - 1$
	\State \quad \IF $\Var{rc}(\Var{obj}) = 0$
	\State \quad \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \quad \IF (\Var{ref} $\neq$ \Null $\wedge$ \Var{*ref} $\neq$ \Var{obj})
	\State \quad \quad \quad \quad \Method{decRefCount}(\Var{*ref})
	\State \quad \quad \Method{free}(\Var{\&obj})
	\State \quad \ELSE
	\State \quad \quad \Method{markGray}(\Var{obj})		\Comment{Entferne Zählung interner Referenzen}
	\State \quad \quad \Method{scan}(\Var{obj})		\Comment{Prüfe Erreichbarkeit}
	\State \quad \quad \Method{collect}(\Var{obj})	\Comment{Entferne unerreichbare Strukturen}
\end{algorithmic}
\caption[Zyklische Referenzzählung]{Zyklische Referenzzählung nach Martínez et al. (vgl. \cite[S. 32]{martinez1990})}
\label{algo:cyclic-rc}
\end{algorithm}

Zusätzlich zum Referenzzähler wird pro Objekt eine Markierungsinformation gespeichert, die die Werte \Var{WHITE}, \Var{GRAY} und \Var{BLACK} annehmen kann (vgl. Abschnitt~\ref{sec:tricolor}).
Nach Untersuchung der hypothetisch zyklischen Struktur sollen erreichbare Objekte weiß und nicht erreichbare schwarz markiert sein.
Zu Beginn sind alle Objekte weiß markiert.
Algorithmus~\ref{algo:cyclic-rc} ergänzt die Prozedur \Method{decRefCount} der naiven Referenzzählung um einen \ELSE-Fall, der ausgelöst wird, wenn der Referenzzähler \Var{rc}(\Var{obj}) nach Dekrementierung nicht $0$ beträgt (vgl. Zeile~8 bis 11).
In diesem Fall muss überprüft werden, ob \Var{obj} das letzte Objekt einer Struktur war, durch welches diese erreichbar war.
Dazu wird nach einem dreischrittigen Verfahren vorgegangen, das im Folgenden beschrieben wird.

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\State \MethodHead{markGray}(\Var{obj}):
	\State \quad \IF \Method{isWhite}(\Var{obj})
	\State \quad \quad \Method{setColor}(\Var{obj}, \Var{GRAY})
	\State \quad \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \quad \IF ($\Var{ref} \neq \Null \wedge \Var{*ref} \neq \Var{obj}$)	\Comment{Entferne interne Referenz,}
	\State \quad \quad \quad \quad $\Var{rc}(\Var{*ref}) \gets \Var{rc}(\Var{*ref})-1$ \Comment{die von \Var{obj} ausgeht}
	\State \quad \quad \quad \quad \Method{markGray}(\Var{*ref})	\Comment{Reduziere rekursiv weitere \Var{rc}}
	\Statex
	\State \MethodHead{scan}(\Var{obj}):
	\State \quad \IF \Method{isGray}(\Var{obj})
	\State \quad \quad \IF $\Var{rc}(\Var{obj}) = 0$	\Comment{Objekt besitzt keine externen Referenzen}
	\State \quad \quad \quad \Method{setColor}(\Var{obj}, \Var{BLACK})
	\State \quad \quad \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \quad \quad \IF ($\Var{ref} \neq \Null \wedge \Var{*ref} \neq \Var{obj}$)
	\State \quad \quad \quad \quad \quad \Method{scan}(\Var{*ref})	\Comment{Prüfe rekursiv referenzierte Objekte}
	\State \quad \quad \ELSE \Method{unmark}(\Var{obj})	\Comment{Objekt besitzt mind. eine externe Referenz}
\end{algorithmic}
\caption[Zyklische Referenzzählung -- Markierungsphase]{Zyklische Referenzzählung -- Markierungsphase (vgl. \cite[S. 32f]{martinez1990})}
\label{algo:cyclic-markscan}
\end{algorithm}

Wir beginnen mit der Prozedur \Method{markGray}, die zunächst für \Var{obj} aufgerufen wird.
Davon ausgehend, dass \Var{obj} Bestandteil einer zyklischen Struktur sein kann, werden zunächst Zählungen von internen Referenzen entfernt, indem alle unmarkierten und von \Var{obj} referenzierten Objekte betrachtet, grau markiert und ihre Referenzzähler angepasst werden (Zeile~3 bis 6 in Algorithmus~\ref{algo:cyclic-markscan}).
Durch einen rekursiven Aufruf in Zeile~7 werden somit alle von \Var{obj} aus erreichbaren Objekte behandelt und grau markiert; ihre Referenzzähler enthalten anschließend die Anzahl aller externen Referenzen.

Im zweiten Schritt wird die Prozedur \Method{scan} für \Var{obj} aufgerufen, um die modifizierten Referenzzähler der grau markierten Objekte auszuwerten.
Besitzt \Var{rc}(\Var{obj}) den Wert $0$, so wird \Var{obj} zunächst schwarz markiert (Zeile~10f).
Das bedeutet, dass \Var{obj} nur von Objekten aus erreichbar ist, die sich innerhalb der starken Zusammenhangskomponente befinden.
Infolgedessen ist die Erreichbarkeit von \Var{obj} von den anderen Objekten der Struktur abhängig: Besitzen diese ebenfalls nur interne Referenzen, ist die gesamte Struktur -- und damit auch \Var{obj} -- unerreichbar.
Um dies zu überprüfen, wird \Method{scan} rekursiv für alle Objekte der Struktur aufgerufen (Zeile~12 bis 14).

Besitzt hingegen ein grau markiertes Objekt \Var{a} einen Referenzzähler mit einem Wert ungleich $0$, so existiert eine externe Referenz auf dieses Objekt -- \Var{a} ist von einem Objekt aus erreichbar, das nicht zur starken Zusammenhangskomponente von \Var{a} gehört.
In diesem Fall wird die Prozedur \Method{unmark} aufgerufen, die \Var{a} weiß markiert (Zeile~2 in Algorithmus~\ref{algo:cyclic-clean}).
Ebenso müssen jedoch auch alle Objekte weiß markiert werden, die von \Var{a} aus erreichbar sind, 
weswegen \Method{unmark} rekursiv für diese Objekte aufgerufen wird (Zeile 7).
Dabei werden gleichzeitig die zugehörigen Referenzzähler angepasst, sodass nach Beendigung diese wieder mit der Anzahl aller Referenzen auf ein Objekt übereinstimmen (Zeile 5).

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\State \MethodHead{unmark}(\Var{obj}):
	\State \quad \Method{setColor}(\Var{obj}, \Var{WHITE})		\Comment{Objekt ist erreichbar}
	\State \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \IF ($\Var{ref} \neq \Null \wedge \Var{*ref} \neq \Var{obj}$)
	\State \quad \quad \quad $\Var{rc}(\Var{*ref}) \gets \Var{rc}(\Var{*ref})+1$ \Comment{Interne Referenz wiederherstellen}
	\State \quad \quad \quad \IF \Method{isNotWhite}(\Var{*ref})
	\State \quad \quad \quad \quad \Method{unmark}(\Var{*ref})
	\Statex
	\State \MethodHead{collect}(\Var{obj}):
	\State \quad \IF \Method{isBlack}(\Var{obj})	\Comment{Objekt ist nicht erreichbar}
	\State \quad \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \quad \IF ($\Var{ref} \neq \Null \wedge \Var{*ref} \neq \Var{obj}$)
	\State \quad \quad \quad \quad \Method{collect}(\Var{*ref})
	\State \quad \quad \Method{free}(\Var{obj})
\end{algorithmic}
\caption[Zyklische Referenzzählung -- Aufräumphase]{Zyklische Referenzzählung -- Aufräumphase (vgl. \cite[S. 33]{martinez1990})}
\label{algo:cyclic-clean}
\end{algorithm}

Nach Abarbeitung von \Method{scan}(\Var{obj}) sind alle zuvor grau markierten Objekte, die von \Var{obj} aus erreichbar sind, schwarz markiert, wenn sie nicht über externe Referenzen erreichbar sind, oder andernfalls weiß markiert und ihre Referenzzähler wiederhergestellt.
Im letzten Schritt können daher alle schwarz markierten Objekte freigegeben werden, was erneut rekursiv durch die Prozedur \Method{collect} geschieht.