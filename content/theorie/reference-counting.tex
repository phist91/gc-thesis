%!TEX root = ../../thesis.tex
\chapter{Referenzzählung}
\label{cha:reference-counting}
Der zweite Garbage-Collection-Algorithmus, der in dieser Arbeit vorgestellt wird, stammt von George Collins und aus dem selben Jahr wie der Mark-Sweep-Algorithmus.
Collins betrachtet wie McCarthy das \textit{LISP Programming System} auf IBM-Großrechnern und das Problem, wann Listenelemente, die prinzipiell in mehreren Listen vorkommen können, wieder freigegeben werden dürfen.
McCarthys Ansatz bezeichnet er jedoch als \enquote{elegant but inefficient} \cite[S. 655]{collins1960}, da dieser sowohl zeitaufwändig sei als auch den Speicherplatz für Nutzdaten einschränke.
Stattdessen schlägt Collins vor, zusätzlich zu einem Datum die Anzahl der Referenzen auf dieses zu speichern.
Anhand dieses Zählers, der bei der Manipulation von Referenzen aktualisiert wird, kann unmittelbar festgestellt werden, ob ein Datum verwaist ist und der entsprechende Speicherplatz freigegeben werden kann \cite[S. 656f]{collins1960}.
Diesen Ansatz -- die \textit{Referenzzählung} (engl. \textit{reference counting}) -- werden wir in diesem Kapitel ausführlich betrachten.

\section{Naive Referenzzählung}
\label{sec:naive-rc}
Zur Realisierung des Algorithmus von Collins in unserem Speichermodell nutzen wir erneut den Header eines Objekts \Var{a}, um dort einen ganzzahligen, nicht negativen Wert \Var{rc}(\Var{a}) zu hinterlegen, den wir als \textit{Referenzzähler} bezeichnen.
Dieser gibt an, wie viele Referenzen von anderen Objekten auf \Var{a} existieren, und wird bei der Erzeugung von \Var{a} mit dem Wert $0$ initialisiert.
Auf diese Art erhalten wir unmittelbar eine notwendige Bedingung für die Erreichbarkeit eines Objekts:
Ist $\Var{a} \in \Reach$, so existiert mindestens ein Objekt $\Var{b} \neq \Var{a}$ mit $\Var{b} \rightarrow \Var{a}$ und somit gilt $\Var{rc}(\Var{a}) \geq 1$.

\begin{mybox}
\begin{lemma}[Notwendige Bedingung für Erreichbarkeit]
\label{lemma:notwendig-rc}
	Für ein Objekt $\Var{a}$ gilt: Ist $\Var{a} \in \Reach$, so folgt $\Var{rc}(\Var{a}) \geq 1$.
\end{lemma}
\end{mybox}

Diese Bedingung ist allerdings nicht hinreichend, da die Objekte, von denen die Referenzen ausgehen, gegebenenfalls nicht erreichbar sind und die Erreichbarkeit von \Var{a} somit nicht garantiert werden kann.
Jedoch folgt als Kontraposition von Lemma~\ref{lemma:notwendig-rc} sofort, dass ein Objekt $\Var{a}$ mit $\Var{rc}(\Var{a}) = 0$ nicht erreichbar ist und freigegeben werden kann.

Wie kann \Var{rc}(\Var{a}) nun verwendet werden, um automatisch ein nicht erreichbares Objekt freizugeben?
Immer, wenn eine Referenz auf \Var{a} in ein Feld eines anderen Objekts geschrieben wird, so muss \Var{rc}(\Var{a}) inkrementiert werden.
Gleichzeitig muss der Referenzzähler des Objekts \Var{b}, welches das Ziel der überschriebenen Referenz war, dekrementiert werden.
Wenn dieser anschließend den Wert $0$ aufweist, kann \Var{b} sofort freigegeben werden.
Diese Manipulationen der Referenzzähler sind unmittelbar auszuführen, nachdem eine Referenz manipuliert wurde.
Daher bieten sich zur Realisierung Schreibbarrieren an, die bereits in Abschnitt~\ref{sec:tricolor} eingeführt wurden.

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\Input Objekt \Var{obj}, in dem Referenz gesetzt wird; Index des Feldes \Var{i}; zu setzende Referenz \Var{ref}
	\State \Atomic \MethodHead{writeRef}(\Var{obj}, \Var{i}, \Var{ref}):
	\State \quad \IF (\Var{ref} $\neq$ \Null $\wedge$ \Var{*ref} $\neq$ \Var{obj})	\Comment{Erhöhe \Var{rc}, falls nicht \Null oder}
	\State \quad \quad $\Var{rc}(\Var{*ref}) \gets \Var{rc}(\Var{*ref}) + 1$ \Comment{Selbstreferenz geschrieben wird}
	\State \quad \IF (\Var{obj[i]} $\neq$ \Null $\wedge$ \Var{*obj[i]} $\neq$ \Var{obj})	\Comment{Reduziere \Var{rc}, falls nicht \Null oder}
	\State \quad \quad \Method{decRefCount}(\Var{*obj[i]})	\Comment{Selbstreferenz überschrieben wird}
	\State \quad \Var{obj[i]} $\gets$ \Var{ref}
	\Statex
	\State \MethodHead{decRefCount}(\Var{obj}):
	\State \quad $\Var{rc}(\Var{obj}) \gets \Var{rc}(\Var{obj}) - 1$
	\State \quad \IF $\Var{rc}(\Var{obj}) = 0$
	\State \quad \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \quad \IF (\Var{ref} $\neq$ \Null $\wedge$ \Var{*ref} $\neq$ \Var{obj}) \Comment{Reduziere rekursiv \Var{rc}}
	\State \quad \quad \quad \quad \Method{decRefCount}(\Var{*ref}) \Comment{referenzierter Objekte}
	\State \quad \quad \Method{free}(\Var{\&obj})
\end{algorithmic}
\caption[Naive Referenzzählung]{Naive Referenzzählung mittels Schreibbarriere (vgl. \cite[S. 58]{handbook}).}
\label{algo:naive-rc}
\end{algorithm}

Die in Algorithmus~\ref{algo:naive-rc} aufgeführte Schreibbarriere kommt genau dann zum Einsatz, wenn mittels $\Var{obj}[i] \gets \Var{ref}$ in ein Feld eines Objekts eine Referenz geschrieben wird.
Dabei wird zunächst geprüft, ob eine Selbstreferenz oder \Null geschrieben werden soll (Zeile 2f).
In beiden Fällen ist der Referenzzähler des Ziels nicht zu erhöhen, da die Operation die Erreichbarkeit des Ziels nicht beeinflusst.
Analog wird überprüft, ob im betroffenen Feld bereits eine Referenz auf ein anderes Objekt gespeichert ist (Zeile 4f).
Wenn ja, muss dessen Referenzzähler entsprechend dekrementiert werden.
Im Anschluss kann die neue Referenz in das Feld des Objekts geschrieben werden.

Das Herabsetzen des Referenzzählers wird durch die Prozedur \Method{decRefCount} übernommen.
Dabei wird zugleich geprüft, ob dieser anschließend $0$ ist (Zeile 9).
In diesem Fall wird das entsprechende Objekt \Var{obj} freigegeben.
Die Freigabe führt allerdings dazu, dass auch die Zähler derjenigen Objekte verringert werden müssen, die von \Var{obj} referenziert werden.
Ensprechend wird für jede Referenz in den Feldern von \Var{obj}, die nicht \Null oder eine Selbstreferenz ist, \Method{decRefCount} rekursiv aufgerufen (Zeile 10 bis 12).

\todo[inline]{Beispiel}

Die Atomizität der Schreibbarriere verhindert die Entstehung von \textit{race conditions} bei gleichzeitigen Zugriffen auf Referenzzähler und ist daher unabdingbar.
Ebenso ist es wesentlich, dass der Referenzzähler des neuen Ziels zunächst inkrementiert wird, bevor der des alten Ziels dekrementiert wird.
Andernfalls könnte es, wenn altes und neues Ziel identisch sind, passieren, dass der Zähler auf $0$ reduziert würde.
In der Folge würde das Ziel sofort freigegeben werden, obwohl es weiterhin erreichbar bliebe.

\begin{mybox}
\begin{satz}[]
\label{satz:rc-correctness}
	Der Algorithmus~\ref{algo:naive-rc} zur Referenzzählung ist korrekt und terminiert.
\end{satz}
\end{mybox}

\begin{proof}
	Zu zeigen ist zunächst, dass die rekursiven Aufrufe von \Method{decRefCount} in Zeile 12 terminieren.
	Angenommen, es gäbe eine nicht terminierende Folge von Aufrufen $\Method{decRefCount}(\Var{a}_1), \Method{decRefCount}(\Var{a}_2), \dots$
	für Objekte $\Var{a}_i, i \in \NN$.
	Da jedes Objekt nur endlich viele Referenzen auf andere Objekte besitzt, ist $\Pointers(\Var{a}_i)$ endlich für alle $i \in \NN$.
	Weiter ist die Anzahl aller Objekte endlich; es muss also ein Objekt $\Var{a}_j$ existieren, für welches $\Method{decRefCount}(\Var{a}_j)$ unendlich oft aufgerufen wird.
	Allerdings wird $\Method{decRefCount}(\Var{a}_j)$ nur aufgerufen, wenn ein Objekt $\Var{b}$ mit $\Var{b} \rightarrow \Var{a}_j$ existiert, für welches zuvor $\Var{rc}(\Var{b})$ auf $0$ gesetzt wurde.
	Da während der rekursiven Aufrufe von \Method{decRefCount} keine Referenzzähler erhöht werden, müssen also unendlich viele verschiedene Objekte \Var{b} mit dieser Eigenschaft existieren.
	Das ist jedoch ein Widerspruch zur Endlichkeit der Anzahl aller Objekte.
	
	Es bleibt zu zeigen, dass der Algorithmus korrekt ist.
	Die Freigabe eines Objekts \Var{a} durch den Algorithmus erfolgt ausschließlich in Zeile 13.
	Diese wird nur ausgelöst, wenn $\Var{rc}(\Var{a}) = 0$ gilt.
	Aus Lemma~\ref{lemma:notwendig-rc} folgt, dass \Var{a} nicht erreichbar ist.
\end{proof}

Die Garbage Collection mithilfe naive Referenzzählung bietet im Vergleich zum Mark-Sweep-Algorithmus einige Vorteile:
Der Mechanismus zur Freigabe von Objekten wird durch die Entstehung von verwaisten Objekten ausgelöst und nicht etwa, wenn nicht genügend freier Speicher zu Verfügung steht.
Dadurch wird die Allokation von Speicher für neu erzeugte Objekte nicht verzögert.
Verwaiste Objekte werden beim Löschen ihrer letzten Referenz unmittelbar erkannt und freigegeben und nicht erst beim nächsten Mark-Sweep-Zyklus.
Speichermangel kann de facto nur dadurch entstehen, dass der gesamte Speicher von erreichbaren Objekten belegt wird -- in diesem Fall bietet allerdings kein Garbage-Collection-Algorithmus Abhilfe.
Referenzzählung benötigt zudem keine Kenntnis über die Struktur des Objektgraphen:
Da kein Aufspüren aller erreichbaren Objekte durchgeführt wird, muss nicht bekannt sein, welche Objekte Basisobjekte sind.
Weiter lässt sich erahnen, dass Referenzzählung weniger stark dazu neigt, Cache-Mechanismen zu beeinträchtigen.
Im Gegensatz zu Mark and Sweep finden kaum unvorhersehbare Objektzugriffe statt.
Wird der Referenzzähler eines Objektes erhöht, so wird gerade eine neue Referenz hierauf angelegt.
Die Wahrscheinlichkeit, dass im Programmablauf kurz danach auch ein Zugriff auf dieses Objekt vorgesehen ist, ist daher relativ hoch.
Zeitliche Lokalität ist somit gegeben.

Trotz dieser Vorteile ist die naive Referenzzählung jedoch kein Allheilmittel.
Dadurch, dass bei jeglicher Referenzänderung eine Manipulation der Zähler erfolgt, werden Operationen des Mutators, die ursprünglich nur lesend auf Objekte zugreifen, zu Schreibzugriffen.
Diese Problematik wird in Verbindung mit dynamischen Datenstrukturen besonders deutlich:
Betrachten wir etwa die lineare Suche auf einer einfach verketteten Liste, so fällt auf, dass bei jeder Iteration die Referenzvariable auf das aktuell betrachtete Element neu gesetzt wird.
Dadurch werden zwei Schreibzugriffe notwendig, die die Zähler des zuletzt betrachteten Objekts reduzieren und des nächsten Objekts erhöhen, obwohl deren Erreichbarkeit tatsächlich nicht beeinflusst wird.
Die Anzahl an Speicheroperationen wird also signifikant vergrößert.

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\State \MethodHead{linSearch}(\Var{list}, \Var{x})):
	\State \quad \Var{cur} $\gets$ \Method{first}(\Var{list})
	\State \quad \WHILE $(\Var{cur} \neq \Null \wedge \Var{*cur} \neq \Var{x})$
	\State \quad \quad \Var{cur} $\gets$ \Method{next}(\Var{list})
	\State \quad \Return \Var{cur} 
\end{algorithmic}
\caption[Lineare Suche]{Lineare Suche in einer verketteten Liste. Obwohl der Algorithmus keine Objekte manipuliert, verursacht jede Änderung an der Referenzvariablen \Var{cur} die Manipulation von zwei Referenzzählern.}
\label{algo:linsearch}
\end{algorithm}