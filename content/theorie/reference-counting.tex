%!TEX root = ../../thesis.tex
\chapter{Referenzzählung}
\label{cha:reference-counting}
Der zweite Garbage-Collection-Algorithmus, der in dieser Arbeit vorgestellt wird, stammt von George Collins und aus dem selben Jahr wie der Mark-Sweep-Algorithmus.
Collins betrachtet wie McCarthy das \textit{LISP Programming System} auf IBM-Großrechnern und das Problem, wann Listenelemente, die prinzipiell in mehreren Listen vorkommen können, wieder freigegeben werden dürfen.
McCarthys Ansatz bezeichnet er jedoch als \enquote{elegant but inefficient} \cite[S. 655]{collins1960}, da dieser sowohl zeitaufwändig sei als auch den Speicherplatz für Nutzdaten einschränke.
Stattdessen schlägt Collins vor, zusätzlich zu einem Datum die Anzahl der Referenzen auf dieses zu speichern.
Anhand dieses Zählers, der bei der Manipulation von Referenzen aktualisiert wird, kann unmittelbar festgestellt werden, ob ein Datum verwaist ist und der entsprechende Speicherplatz freigegeben werden kann \cite[S. 656f]{collins1960}.
Diesen Ansatz -- die \textit{Referenzzählung} (engl. \textit{reference counting}) -- werden wir in diesem Kapitel ausführlich betrachten.

\section{Naive Referenzzählung}
\label{sec:naive-rc}
Zur Realisierung des Algorithmus von Collins in unserem Speichermodell nutzen wir erneut den Header eines Objekts \Var{a}, um dort einen ganzzahligen, nicht negativen Wert \Var{rc}(\Var{a}) zu hinterlegen, den wir als \textit{Referenzzähler} bezeichnen.
Dieser gibt an, wie viele Referenzen von anderen Objekten auf \Var{a} existieren, und wird bei der Erzeugung von \Var{a} mit dem Wert $0$ initialisiert.
Auf diese Art erhalten wir unmittelbar eine notwendige Bedingung für die Erreichbarkeit eines Objekts:
Ist $\Var{a} \in \Reach$, so existiert mindestens ein Objekt $\Var{b} \neq \Var{a}$ mit $\Var{b} \rightarrow \Var{a}$ und somit gilt $\Var{rc}(\Var{a}) \geq 1$.

\begin{mybox}
\begin{lemma}[Notwendige Bedingung für Erreichbarkeit]
\label{lemma:notwendig-rc}
	Für ein Objekt $\Var{a}$ gilt: Ist $\Var{a} \in \Reach$, so folgt $\Var{rc}(\Var{a}) \geq 1$.
\end{lemma}
\end{mybox}

Diese Bedingung ist allerdings nicht hinreichend, da die Objekte, von denen die Referenzen ausgehen, gegebenenfalls nicht erreichbar sind und die Erreichbarkeit von \Var{a} somit nicht garantiert werden kann.
Jedoch folgt als Kontraposition von Lemma~\ref{lemma:notwendig-rc} sofort, dass ein Objekt $\Var{a}$ mit $\Var{rc}(\Var{a}) = 0$ nicht erreichbar ist und freigegeben werden kann.

Wie kann \Var{rc}(\Var{a}) nun verwendet werden, um automatisch ein nicht erreichbares Objekt freizugeben?
Immer, wenn eine Referenz auf \Var{a} in ein Feld eines anderen Objekts geschrieben wird, so muss \Var{rc}(\Var{a}) inkrementiert werden.
Gleichzeitig muss der Referenzzähler des Objekts \Var{b}, welches das Ziel der überschriebenen Referenz war, dekrementiert werden.
Wenn dieser anschließend den Wert $0$ aufweist, kann \Var{b} sofort freigegeben werden.
Diese Manipulationen der Referenzzähler sind unmittelbar auszuführen, nachdem eine Referenz manipuliert wurde.
Daher bieten sich zur Realisierung Schreibbarrieren an, die bereits in Abschnitt~\ref{sec:tricolor} eingeführt wurden.

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\Input Objekt \Var{obj}, in dem Referenz gesetzt wird; Index des Feldes \Var{i}; zu setzende Referenz \Var{ref}
	\State \Atomic \MethodHead{writeRef}(\Var{obj}, \Var{i}, \Var{ref}):
	\State \quad \IF (\Var{ref} $\neq$ \Null $\wedge$ \Var{*ref} $\neq$ \Var{obj})	\Comment{Erhöhe \Var{rc}, falls nicht \Null oder}
	\State \quad \quad $\Var{rc}(\Var{*ref}) \gets \Var{rc}(\Var{*ref}) + 1$ \Comment{Selbstreferenz geschrieben wird}
	\State \quad \IF (\Var{obj[i]} $\neq$ \Null $\wedge$ \Var{*obj[i]} $\neq$ \Var{obj})	\Comment{Reduziere \Var{rc}, falls nicht \Null oder}
	\State \quad \quad \Method{decRefCount}(\Var{*obj[i]})	\Comment{Selbstreferenz überschrieben wird}
	\State \quad \Var{obj[i]} $\gets$ \Var{ref}
	\Statex
	\State \MethodHead{decRefCount}(\Var{obj}):
	\State \quad $\Var{rc}(\Var{obj}) \gets \Var{rc}(\Var{obj}) - 1$
	\State \quad \IF $\Var{rc}(\Var{obj}) = 0$
	\State \quad \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \quad \IF (\Var{ref} $\neq$ \Null $\wedge$ \Var{*ref} $\neq$ \Var{obj}) \Comment{Reduziere rekursiv \Var{rc}}
	\State \quad \quad \quad \quad \Method{decRefCount}(\Var{*ref}) \Comment{referenzierter Objekte}
	\State \quad \quad \Method{free}(\Var{\&obj})
\end{algorithmic}
\caption[Naive Referenzzählung]{Naive Referenzzählung mittels Schreibbarriere (vgl. \cite[S. 58]{handbook}).}
\label{algo:naive-rc}
\end{algorithm}

Die in Algorithmus~\ref{algo:naive-rc} aufgeführte Schreibbarriere kommt genau dann zum Einsatz, wenn mittels $\Var{obj}[i] \gets \Var{ref}$ in ein Feld eines Objekts eine Referenz geschrieben wird.
Dabei wird zunächst geprüft, ob eine Selbstreferenz oder \Null geschrieben werden soll (Zeile 2f).
In beiden Fällen ist der Referenzzähler des Ziels nicht zu erhöhen, da die Operation die Erreichbarkeit des Ziels nicht beeinflusst.
Analog wird überprüft, ob im betroffenen Feld bereits eine Referenz auf ein anderes Objekt gespeichert ist (Zeile 4f).
Wenn ja, muss dessen Referenzzähler entsprechend dekrementiert werden.
Im Anschluss kann die neue Referenz in das Feld des Objekts geschrieben werden.

Das Herabsetzen des Referenzzählers wird durch die Prozedur \Method{decRefCount} übernommen.
Dabei wird zugleich geprüft, ob dieser anschließend $0$ ist (Zeile 9).
In diesem Fall wird das entsprechende Objekt \Var{obj} freigegeben.
Die Freigabe führt allerdings dazu, dass auch die Zähler derjenigen Objekte verringert werden müssen, die von \Var{obj} referenziert werden.
Ensprechend wird für jede Referenz in den Feldern von \Var{obj}, die nicht \Null oder eine Selbstreferenz ist, \Method{decRefCount} rekursiv aufgerufen (Zeile 10 bis 12).

\begin{figure}[h]
	\centering
	\includestandalone{img/tikz/ch3-refcount}~\hspace{1cm}~
	\includestandalone{img/tikz/ch3-refcount2}
	\caption[Beispiel für Referenzzählung]{Wird die Referenz $\Var{a} \rightarrow \Var{b}$ entfernt, so wird \Var{b} freigegeben, da der Referenzzähler von \Var{b} auf $0$ fällt. In der Folge müssen auch die Referenzzähler von \Var{c} und \Var{d} angepasst werden.}
	\label{fig:rc-example}
\end{figure}

Die Atomizität der Schreibbarriere verhindert die Entstehung von \textit{race conditions} bei gleichzeitigen Zugriffen auf Referenzzähler und ist daher unabdingbar.
Ebenso ist es wesentlich, dass der Referenzzähler des neuen Ziels zunächst inkrementiert wird, bevor der des alten Ziels dekrementiert wird.
Andernfalls könnte es, wenn altes und neues Ziel identisch sind, passieren, dass der Zähler auf $0$ reduziert würde.
In der Folge würde das Ziel sofort freigegeben werden, obwohl es weiterhin erreichbar bliebe.

\begin{mybox}
\begin{satz}[]
\label{satz:rc-correctness}
	Der Algorithmus~\ref{algo:naive-rc} zur Referenzzählung ist korrekt und terminiert.
\end{satz}
\end{mybox}

\begin{proof}
	Zu zeigen ist zunächst, dass die rekursiven Aufrufe von \Method{decRefCount} in Zeile 12 terminieren.
	Angenommen, es gäbe eine nicht terminierende Folge von Aufrufen $\Method{decRefCount}(\Var{a}_1), \Method{decRefCount}(\Var{a}_2), \dots$
	für Objekte $\Var{a}_i, i \in \NN$.
	Da jedes Objekt nur endlich viele Referenzen auf andere Objekte besitzt, ist $\Pointers(\Var{a}_i)$ endlich für alle $i \in \NN$.
	Weiter ist die Anzahl aller Objekte endlich; es muss also ein Objekt $\Var{a}_j$ existieren, für welches $\Method{decRefCount}(\Var{a}_j)$ unendlich oft aufgerufen wird.
	Allerdings wird $\Method{decRefCount}(\Var{a}_j)$ nur aufgerufen, wenn ein Objekt $\Var{b}$ mit $\Var{b} \rightarrow \Var{a}_j$ existiert, für welches zuvor $\Var{rc}(\Var{b})$ auf $0$ gesetzt wurde.
	Da während der rekursiven Aufrufe von \Method{decRefCount} keine Referenzzähler erhöht werden, müssen also unendlich viele verschiedene Objekte \Var{b} mit dieser Eigenschaft existieren.
	Das ist jedoch ein Widerspruch zur Endlichkeit der Anzahl aller Objekte.
	
	Es bleibt zu zeigen, dass der Algorithmus korrekt ist.
	Die Freigabe eines Objekts \Var{a} durch den Algorithmus erfolgt ausschließlich in Zeile 13.
	Diese wird nur ausgelöst, wenn $\Var{rc}(\Var{a}) = 0$ gilt.
	Aus Lemma~\ref{lemma:notwendig-rc} folgt, dass \Var{a} nicht erreichbar ist.
\end{proof}

Die Garbage Collection mithilfe naive Referenzzählung bietet im Vergleich zum Mark-Sweep-Algorithmus einige Vorteile, aber auch gewisse Nachteile (vgl. \cite[S. 346]{linhou2006}):
Der Mechanismus zur Freigabe von Objekten wird durch die Entstehung von verwaisten Objekten ausgelöst und nicht etwa, wenn unzureichend freier Speicher zu Verfügung steht.
Dadurch wird die Allokation von Speicher für neu erzeugte Objekte nicht verzögert.
Verwaiste Objekte werden beim Löschen ihrer letzten Referenz unmittelbar erkannt und freigegeben und nicht erst beim nächsten Mark-Sweep-Zyklus.
Speichermangel kann so de facto nur dadurch entstehen, dass der gesamte Speicher von erreichbaren Objekten belegt wird -- in diesem Fall bietet allerdings kein Garbage-Collection-Algorithmus Abhilfe.
Referenzzählung benötigt zudem keinen Zugriff auf den vollständigen Objektgraphen:
Da kein Aufspüren aller erreichbaren Objekte durchgeführt wird, kann auf eine Traversierung des Objektgraphen verzichtet werden.
Dies ist besonders für verteilte Systeme von Vorteil, in denen die Markierungsphase sonst mehrere Knoten des Systems belasten und erhöhten Datenaustausch zwischen diesen verursachen würde.
Weiter lässt sich erahnen, dass Referenzzählung weniger stark dazu neigt, Cache-Mechanismen zu beeinträchtigen.
Im Gegensatz zu Mark and Sweep finden kaum unvorhersehbare Objektzugriffe statt.
Wird der Referenzzähler eines Objektes erhöht, so wird gerade eine neue Referenz hierauf angelegt.
Die Wahrscheinlichkeit, dass im Programmablauf kurz danach auch ein Zugriff auf dieses Objekt vorgesehen ist, ist daher relativ hoch.
Zeitliche Lokalität ist somit gegeben.

Trotz dieser Vorteile ist die naive Referenzzählung jedoch kein Allheilmittel.
Dadurch, dass bei jeglicher Referenzänderung eine Manipulation der Zähler erfolgt, werden Operationen des Mutators, die ursprünglich nur lesend auf Objekte zugreifen, zu Schreibzugriffen.
Diese Problematik wird in Verbindung mit dynamischen Datenstrukturen besonders deutlich:
Betrachten wir etwa die lineare Suche auf einer einfach verketteten Liste, so fällt auf, dass bei jeder Iteration die Referenzvariable auf das aktuell betrachtete Element neu gesetzt wird (Zeile 4 in Algorithmus~\ref{algo:linsearch}).
Dadurch werden zwei Schreibzugriffe notwendig, die die Zähler des zuletzt betrachteten Objekts reduzieren und des nächsten Objekts erhöhen, obwohl deren Erreichbarkeit tatsächlich nicht beeinflusst wird.
Die Anzahl an Speicheroperationen wird also signifikant vergrößert.
Durch den rekursiven Aufruf von \Method{decRefCount} kann es zudem zu einer Kaskade an Freigaben und Zählermanipulationen kommen, sobald ein Objekt freigegeben wird.
In Verbindung mit der Atomizität der Schreibbarriere können dadurch größere und unerwartete Verzögerungen im Programmablauf entstehen, die bei zeitkritischen Anwendungen um jeden Preis zu vermeiden sind.

\todo[inline]{Overhead durch viele kleine Objekte (Deutsch/Bobrow)}

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\State \MethodHead{linSearch}(\Var{list}, \Var{x}):
	\State \quad \Var{cur} $\gets$ \Method{first}(\Var{list})
	\State \quad \WHILE $(\Var{cur} \neq \Null \wedge \Var{*cur} \neq \Var{x})$
	\State \quad \quad \Var{cur} $\gets$ \Method{next}(\Var{list})
	\State \quad \Return \Var{cur} 
\end{algorithmic}
\caption[Lineare Suche]{Lineare Suche in einer verketteten Liste. Obwohl der Algorithmus keine Objekte manipuliert, verursacht jede Änderung an der Referenzvariablen \Var{cur} die Manipulation von zwei Referenzzählern.}
\label{algo:linsearch}
\end{algorithm}

Ein weiteres Problem entsteht, wenn zyklische Datenstrukturen wie etwa doppelt verkettete Listen verwendet werden.
Die gesamte Struktur kann unerreichbar sein, obwohl die Referenzzähler der einzelnen Objekte nicht $0$ sind (siehe Abbildung~\ref{fig:rc-cycle}).
Die einzelnen Objekte werden dann nicht als löschbar erkannt, was zu einem Speicherleck führt.
Eine mögliche Lösung dieser Problematik wird im nächsten Abschnitt betrachtet.
Im Anschluss daran werden weitere Ansätze vorgestellt, die eine Effizienzsteigerung der naiven Referenzzählung anstreben. \todo[inline]{Ausblick auf nächste Abschnitte}

\begin{figure}[h]
	\centering
	\includestandalone{img/tikz/ch3-cycle}
	\caption[Referenzzählung in zyklischen Datenstrukturen]{Referenzzählung in zyklischen Datenstrukturen. Wird Objekt \Var{L} entfernt, sind \Var{a} und \Var{b} nicht mehr erreichbar. Jedoch fallen ihre Referenzzähler nicht auf $0$, sodass sie als Speicherlecks im Speicher verbleiben.}
	\label{fig:rc-cycle}
\end{figure}

\section{Zyklische Referenzen}
\label{sec:cyclic-rc}
Die fehlende Möglichkeit zur Erkennung und Freigabe zyklischer Strukturen kann -- bei entsprechend häufiger Verwendung -- große Teile des Heaps brachliegen lassen.
Ein gelegentlich zusätzlich ausgeführter Mark-Sweep-Zyklus mag diese Problematik zwar beheben, macht allerdings die oben genannten Vorteile der Referenzzählung zunichte.
Nachfolgend stellen wir einen Algorithmus von Martínez, Wachenchauzer und Lins vor, der die naive Referenzählung um ein Verfahren ergänzt, mit welchem zyklische Strukturen zuverlässig erkannt werden können \cite{martinez1990}.
Dieses basiert darauf, dass ein Zyklus von Objekten als \textit{starke Zusammenhangskomponente} im Objektgraphen aufgefasst werden kann (vgl. \cite[S. 348]{linhou2006}).
Das bedeutet, dass von jedem Objekt aus jedes andere Objekt innerhalb des Zyklus erreicht werden kann.

\begin{mybox}
\begin{defn}[Starke Zusammenhangskomponente]
\label{def:zusammenhang}
	Sei $O$ eine Menge von Objekten und $\Var{a} \in O$.
	$\sk{\Var{a}} \subseteq O$ heißt \textbf{starke Zusammenhangskomponente} von \Var{a}, wenn gilt:
	\begin{enumerate}[(1)]
		\item $\Var{a} \in \sk{\Var{a}}$
		\item Für alle $\Var{b}, \Var{c} \in \sk{\Var{a}}$ gilt $\Var{b} \transreach \Var{c}$ und $\Var{c} \transreach \Var{b}$.
		\item $\sk{\Var{a}}$ ist maximal, das heißt für jede Teilmenge $M \subseteq O$, die \textbf{(1)} und \textbf{(2)} erfüllt, gilt $M \subseteq \sk{\Var{a}}$.
	\end{enumerate}
	Eine Referenz $\Var{x} \rightarrow \Var{a}$ von $\Var{a}$ heißt \textbf{intern}, wenn $\Var{x} \in \sk{\Var{a}}$.
	Andernfalls heißt sie \textbf{extern}.	
\end{defn}
\end{mybox}

Man kann leicht sehen, dass die starke Zusammenhangskomponente eines Objekts eindeutig bestimmt ist und zwei starke Zusammenhangskomponenten entweder identisch oder disjunkt sind.\footnote{Betrachtet man die Relation $\sim$ auf $O$ definiert durch $\Var{a} \sim \Var{b} :\Leftrightarrow \Var{a} = \Var{b} \vee \Var{a} \transreach \Var{b} \wedge \Var{b} \transreach \Var{a}$, so ist leicht zu sehen, dass diese eine Äquivalenzrelation auf $O$ ist. Die Menge $\sk{\Var{a}}$ ist dann nichts anderes als die Äquivalenzklasse $[\Var{a}]_{\sim}$ von $\Var{a} \in O$ bezüglich $\sim$. Entsprechend lässt sich die Menge $O$ in ihre starken Zusammenhangskomponenten partitionieren.}

\begin{figure}[h]
	\centering
	\includestandalone{img/tikz/ch3-scc}
	\caption[Beispiel für starke Zusammenhangskomponenten]{Der abgebildete Objektgraph besitzt drei starke Zusammenhangskomponenten: $\sk{\Var{a}} = \{\Var{a}\}$, $\sk{\Var{b}} = \{\Var{b}, \Var{c}, \Var{d}\}$ und $\sk{\Var{e}} = \{\Var{e}\}$.}
	\label{fig:rc-scc}
\end{figure}

Passt man die Referenzzähler jedes Objekts so an, dass interne Referenzen unberücksichtigt bleiben, geben diese anschließend Auskunft darüber, wie viele externe Referenzen von Objekten außerhalb der Komponente auf Objekte innerhalb der Komponente existieren.
Besitzen alle so modifierten Zähler den Wert $0$, so ist die Komponente nicht mehr erreichbar und kann entfernt werden.
Anders formuliert: Besitzt die Komponente ein Objekt, das über eine externe Referenz erreichbar ist, so ist die gesamte Komponente von außen erreichbar.

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\State \MethodHead{decRefCount}(\Var{obj}):
	\State \quad $\Var{rc}(\Var{obj}) \gets \Var{rc}(\Var{obj}) - 1$
	\State \quad \IF $\Var{rc}(\Var{obj}) = 0$
	\State \quad \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \quad \IF (\Var{ref} $\neq$ \Null $\wedge$ \Var{*ref} $\neq$ \Var{obj})
	\State \quad \quad \quad \quad \Method{decRefCount}(\Var{*ref})
	\State \quad \quad \Method{free}(\Var{\&obj})
	\State \quad \ELSE
	\State \quad \quad \Method{markGray}(\Var{obj})		\Comment{Entferne Zählung interner Referenzen}
	\State \quad \quad \Method{scan}(\Var{obj})		\Comment{Prüfe Erreichbarkeit}
	\State \quad \quad \Method{collect}(\Var{obj})	\Comment{Entferne unerreichbare Strukturen}
\end{algorithmic}
\caption[Zyklische Referenzzählung]{Zyklische Referenzzählung nach Martínez et al. (vgl. \cite[S. 32]{martinez1990})}
\label{algo:cyclic-rc}
\end{algorithm}

Zusätzlich zum Referenzzähler wird pro Objekt eine Markierungsinformation gespeichert, die die Werte \Var{WHITE}, \Var{GRAY} und \Var{BLACK} annehmen kann (vgl. Abschnitt~\ref{sec:tricolor}).
Nach Untersuchung der hypothetisch zyklischen Struktur sollen erreichbare Objekte weiß und nicht erreichbare schwarz markiert sein.
Zu Beginn sind alle Objekte weiß markiert.
Algorithmus~\ref{algo:cyclic-rc} ergänzt die Prozedur \Method{decRefCount} der naiven Referenzzählung um einen \ELSE-Fall, der ausgelöst wird, wenn der Referenzzähler \Var{rc}(\Var{obj}) nach Dekrementierung nicht $0$ beträgt (vgl. Zeile~8 bis 11).
In diesem Fall muss überprüft werden, ob \Var{obj} das letzte Objekt einer Struktur war, durch welches diese erreichbar war.
Dazu wird nach einem dreischrittigen Verfahren vorgegangen, das im Folgenden beschrieben wird.

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\State \MethodHead{markGray}(\Var{obj}):
	\State \quad \IF \Method{isWhite}(\Var{obj})
	\State \quad \quad \Method{setColor}(\Var{obj}, \Var{GRAY})
	\State \quad \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \quad \IF ($\Var{ref} \neq \Null \wedge \Var{*ref} \neq \Var{obj}$)	\Comment{Entferne interne Referenz,}
	\State \quad \quad \quad \quad $\Var{rc}(\Var{*ref}) \gets \Var{rc}(\Var{*ref})-1$ \Comment{die von \Var{obj} ausgeht}
	\State \quad \quad \quad \quad \Method{markGray}(\Var{*ref})	\Comment{Reduziere rekursiv weitere \Var{rc}}
	\Statex
	\State \MethodHead{scan}(\Var{obj}):
	\State \quad \IF \Method{isGray}(\Var{obj})
	\State \quad \quad \IF $\Var{rc}(\Var{obj}) = 0$	\Comment{Objekt besitzt keine externen Referenzen}
	\State \quad \quad \quad \Method{setColor}(\Var{obj}, \Var{BLACK})
	\State \quad \quad \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \quad \quad \IF ($\Var{ref} \neq \Null \wedge \Var{*ref} \neq \Var{obj}$)
	\State \quad \quad \quad \quad \quad \Method{scan}(\Var{*ref})	\Comment{Prüfe rekursiv referenzierte Objekte}
	\State \quad \quad \ELSE \Method{unmark}(\Var{obj})	\Comment{Objekt besitzt mind. eine externe Referenz}
\end{algorithmic}
\caption[Zyklische Referenzzählung -- Markierungsphase]{Zyklische Referenzzählung -- Markierungsphase (vgl. \cite[S. 32f]{martinez1990})}
\label{algo:cyclic-markscan}
\end{algorithm}

Wir beginnen mit der Prozedur \Method{markGray}, die zunächst für \Var{obj} aufgerufen wird.
Davon ausgehend, dass \Var{obj} Bestandteil einer zyklischen Struktur sein kann, werden zunächst Zählungen von internen Referenzen entfernt, indem per Tiefensuche alle unmarkierten und von \Var{obj} referenzierten Objekte betrachtet, grau markiert und ihre Referenzzähler angepasst werden (Zeile~3 bis 6 in Algorithmus~\ref{algo:cyclic-markscan}).
Durch einen rekursiven Aufruf in Zeile~7 werden somit die starke Zusammenhangskomponente $\sk{\Var{obj}}$ behandelt und grau markiert; ihre Referenzzähler enthalten anschließend die Anzahl aller externen Referenzen.

Im zweiten Schritt wird die Prozedur \Method{scan} für \Var{obj} aufgerufen, um die modifizierten Referenzzähler der grau markierten Objekte auszuwerten.
Besitzt \Var{rc}(\Var{obj}) den Wert $0$, so wird \Var{obj} zunächst schwarz markiert (Zeile~10f).
Das bedeutet, dass \Var{obj} nur von Objekten aus erreichbar ist, die sich innerhalb der starken Zusammenhangskomponente befinden.
Infolgedessen ist die Erreichbarkeit von \Var{obj} von den anderen Objekten der Komponente abhängig: Besitzen diese ebenfalls nur interne Referenzen, ist die gesamte Komponente -- und damit auch \Var{obj} -- unerreichbar.
Um dies zu überprüfen, wird \Method{scan} rekursiv für alle Objekte von $\sk{\Var{obj}}$ aufgerufen (Zeile~12 bis 14).

Besitzt hingegen ein grau markiertes Objekt \Var{a} einen Referenzzähler mit einem Wert ungleich $0$, so existiert eine externe Referenz auf dieses Objekt -- \Var{a} ist von einem Objekt aus erreichbar, das nicht zu $\sk{\Var{a}}$ gehört.
In diesem Fall wird die Prozedur \Method{unmark} aufgerufen, die \Var{a} weiß markiert (Zeile~2 in Algorithmus~\ref{algo:cyclic-clean}).
Ebenso müssen jedoch auch alle Objekte weiß markiert werden, die von \Var{a} aus erreichbar sind, 
weswegen \Method{unmark} rekursiv für diese Objekte aufgerufen wird (Zeile 7).
Dabei werden gleichzeitig die zugehörigen Referenzzähler angepasst, sodass nach Beendigung diese wieder mit der Anzahl aller Referenzen auf ein Objekt übereinstimmen (Zeile 5).

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\State \MethodHead{unmark}(\Var{obj}):
	\State \quad \Method{setColor}(\Var{obj}, \Var{WHITE})		\Comment{Objekt ist erreichbar}
	\State \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \IF ($\Var{ref} \neq \Null \wedge \Var{*ref} \neq \Var{obj}$)
	\State \quad \quad \quad $\Var{rc}(\Var{*ref}) \gets \Var{rc}(\Var{*ref})+1$ \Comment{Interne Referenz wiederherstellen}
	\State \quad \quad \quad \IF \Method{isNotWhite}(\Var{*ref})
	\State \quad \quad \quad \quad \Method{unmark}(\Var{*ref})
	\Statex
	\State \MethodHead{collect}(\Var{obj}):
	\State \quad \IF \Method{isBlack}(\Var{obj})	\Comment{Objekt ist nicht erreichbar}
	\State \quad \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \quad \IF ($\Var{ref} \neq \Null \wedge \Var{*ref} \neq \Var{obj}$)
	\State \quad \quad \quad \quad \Method{collect}(\Var{*ref})
	\State \quad \quad \Method{free}(\Var{obj})
\end{algorithmic}
\caption[Zyklische Referenzzählung -- Aufräumphase]{Zyklische Referenzzählung -- Aufräumphase (vgl. \cite[S. 33]{martinez1990})}
\label{algo:cyclic-clean}
\end{algorithm}

Nach Abarbeitung von \Method{scan}(\Var{obj}) sind alle zuvor grau markierten Objekte, die von \Var{obj} aus erreichbar sind, schwarz markiert, wenn sie nicht über externe Referenzen erreichbar sind, oder andernfalls weiß markiert und ihre Referenzzähler wiederhergestellt.
Im letzten Schritt können daher alle schwarz markierten Objekte freigegeben werden, was erneut rekursiv durch die Prozedur \Method{collect} geschieht.

Um die Arbeit des Algorithmus zu veranschaulichen, betrachten wir den Objektgraphen aus Abbildung~\ref{fig:rc-scc} und nehmen an, dass die Referenz $\Var{a} \rightarrow \Var{b}$ entfernt wird, wodurch die Objekte \Var{b}, \Var{c}, \Var{d} und \Var{e} unerreichbar werden.
Wir erwarten daher, dass der Aufruf von \Method{markGray}(\Var{b}), \Method{scan}(\Var{b}) und \Method{collect}(\Var{b}) alle vier Objekte freigibt.

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.4\textwidth}
		\centering
		\includestandalone{img/tikz/ch3-cyclic-ex1}
	\end{subfigure}~\hspace{0.5cm}~
	\begin{subfigure}{0.473\textwidth}
		\centering
		\includestandalone{img/tikz/ch3-cyclic-ex2}
	\end{subfigure}\\[1cm]
	\begin{subfigure}{0.4\textwidth}
		\centering
		\includestandalone{img/tikz/ch3-cyclic-ex3}
	\end{subfigure}~\hspace{0.5cm}~
	\begin{subfigure}{0.4\textwidth}
		\centering
		\includestandalone{img/tikz/ch3-cyclic-ex4}
	\end{subfigure}\\[1cm]
	\begin{subfigure}{0.4\textwidth}
		\centering
		\includestandalone{img/tikz/ch3-cyclic-ex5}
	\end{subfigure}~\hspace{0.5cm}~
	\begin{subfigure}{0.4\textwidth}
		\centering
		\includestandalone{img/tikz/ch3-cyclic-ex6}
	\end{subfigure}
	\caption[Ausführung von \Method{markGray}(\Var{b})]{Beispielhafte Ausführung von \Method{markGray}(\Var{b}) nach Entfernen der Referenz $\Var{a} \rightarrow \Var{b}$. Dick umrandet ist das jeweilige Objekt, für welches gerade der rekursive Aufruf von \Method{markGray} stattfindet.}
	\label{fig:rc-markgray-example}
\end{figure}

Zunächst wird durch \Method{markGray} Objekt \Var{b} grau markiert (siehe Abbildung~\ref{fig:rc-markgray-example}).
Im Anschluss erfolgt für jedes von \Var{b} referenzierte Objekt -- hier \Var{e} und \Var{c} -- eine Verringerung des zugehörigen Referenzzählers sowie ein rekursiver Aufruf von \Method{markGray}.
Der Aufruf \Method{markGray}(\Var{c}) erniedrigt den Referenzzähler von \Var{d}; \Method{markGray}(\Var{d}) sorgt für eine erneute Modifikation von \Var{rc}(\Var{b}) und \Var{rc}(\Var{c}).
An dieser Stelle geschehen jedoch keine rekursiven Aufrufe mehr, da alle von \Var{d} referenzierten Objekte bereits grau markiert sind.
Somit terminieren hier die Aufrufe von \Method{markGray}(\Var{d}), \Method{markGray}(\Var{c}) und \Method{markGray}(\Var{b}).

An dieser Stelle können wir bereits erkennen, dass alle Referenzzähler von $\sk{\Var{b}}$ $0$ sind, weswegen der Zyklus keine externen Referenzen besitzt und nicht mehr erreichbar ist.
Dies wird nun von \Method{scan} mittels einer weiteren Tiefensuche beginnend bei \Var{b} überprüft.
Da alle von \Var{b} aus erreichbaren Objekte grau markiert sind und ihre Referenzzähler verschwinden, werden sie schwarz markiert; ein Aufruf von \Method{unmark} findet nicht statt.
Somit werden anschließend alle vier Knoten durch \Method{collect} mittels einer dritten Tiefensuche freigegeben.

Was passiert jedoch, wenn der Zyklus erreichbar bleibt?
Wir ergänzen das Beispiel um eine externe Referenz auf das Objekt \Var{d} (siehe Abbildung~\ref{fig:rc-unmark-example}).
Nach Terminierung von \Method{markGray}(\Var{b}) weist \Var{rc}(\Var{d}) dann den Wert $1$ auf.
Durch den Aufruf \Method{scan}(\Var{b}) werden zunächst wie zuvor \Var{b}, \Var{e} und \Var{c} schwarz markiert.
Da allerdings $\Var{rc}(\Var{d}) \neq 0$ gilt, folgt nun ein Aufruf von \Method{unmark}(\Var{d}), wodurch \Var{d} weiß markiert wird.
Hierdurch wird eine weitere Tiefensuche angestoßen, die die von \Var{d} aus erreichbaren Objekte traversiert, weiß markiert und ihre Referenzzähler zurücksetzt.
Der anschließend noch abzuarbeitende Aufruf von \Method{scan}(\Var{b}) markiert lediglich graue Objekte schwarz.
Somit sind letztlich keine schwarz markierten Objekte vorhanden und kein Objekt des Zyklus wird entfernt.

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.4\textwidth}
		\centering
		\includestandalone{img/tikz/ch3-cyclic-ex11}
	\end{subfigure}~\hspace{0.5cm}~
	\begin{subfigure}{0.4\textwidth}
		\centering
		\includestandalone{img/tikz/ch3-cyclic-ex12}
	\end{subfigure}\\[1cm]
	\begin{subfigure}{0.4\textwidth}
		\centering
		\includestandalone{img/tikz/ch3-cyclic-ex13}
	\end{subfigure}~\hspace{0.5cm}~
	\begin{subfigure}{0.4\textwidth}
		\centering
		\includestandalone{img/tikz/ch3-cyclic-ex14}
	\end{subfigure}\\[1cm]
	\begin{subfigure}{0.4\textwidth}
		\centering
		\includestandalone{img/tikz/ch3-cyclic-ex15}
	\end{subfigure}~\hspace{0.5cm}~
	\begin{subfigure}{0.4\textwidth}
		\centering
		\includestandalone{img/tikz/ch3-cyclic-ex16}
	\end{subfigure}
	\caption[Ausführung von \Method{unmark}(\Var{d})]{Beispielhafte Ausführung von \Method{unmark}(\Var{d}) nach \Method{markGray}(\Var{b}).}
	\label{fig:rc-unmark-example}
\end{figure}

Wir zeigen nun, dass die zyklische Referenzzählung nach Martínez et al. korrekt ist, wobei wir weiterhin voraussetzen, dass der Algorithmus atomar ausgeführt wird.

\begin{mybox}
\begin{satz}[Korrektheit der zyklischen Referenzzählung]
\label{satz:cyclic-rc-correctness}
	Die zyklische Referenzzählung nach Martínez et al. ist korrekt und terminiert.
\end{satz}
\end{mybox}

\begin{proof}
	Wir zeigen zunächst, dass die Aufrufe der Prozeduren \Method{markGray}, \Method{scan} und \Method{collect} (Zeile 9 bis 11 in Algorithmus~\ref{algo:cyclic-rc}) terminieren:
	Für \Method{markGray} ist dies leicht zu sehen, da \Method{markGray} lediglich weiß markierte Objekte manipuliert und diese sofort grau färbt (Zeile 2f in Algorithmus~\ref{algo:cyclic-markscan}).
	Analoges gilt für \Method{collect} und schwarz gefärbte Objekte.
	\Method{scan} wiederum verändert nur grau markierte Objekte.
	Ist der Referenzzähler eines Objektes $0$, für welches \Method{scan} aufgerufen wird, so wird dieses schwarz gefärbt.
	Andernfalls wird das Objekt durch \Method{unmark} weiß markiert.
	In beiden Fällen ist damit sichergestellt, dass ein Objekt nicht mehrfach durch \Method{scan} bzw. \Method{unmark} bearbeitet wird und keine weiteren rekursiven Aufrufe stattfinden.
	Somit terminieren alle drei Aufrufe.
	
	Wird nun ein Objekt \Var{a} durch \Method{collect} freigegeben, so wurde \Var{a} zuvor schwarz markiert (Zeile 9 und 13 in Algorithmus~\ref{algo:cyclic-clean}).
	Dies passiert ausschließlich in der Prozedur \Method{scan}, wenn \Var{a} keine externen Referenzen besitzt.
	Wäre \Var{a} erreichbar, so müsste folglich ein Objekt $\Var{b} \in \sk{\Var{a}}$ existieren, das ebenfalls erreichbar ist, also eine externe Referenz besitzt.
	In diesem Fall wird \Var{b} jedoch durch \Method{unmark} weiß markiert und rekursiv auch \Var{a}, da $\Var{b} \transreach \Var{a}$.
	Das ist jedoch ein Widerspruch, da weiß markierte Objekte nach Terminierung von \Method{markGray} nicht mehr schwarz markiert werden.
	Somit kann \Var{a} nicht erreichbar sein.
\end{proof}

Der vorgestellte Algorithmus löst zwar das Problem brachliegender zyklischer Strukturen, allerdings zu einem hohen Preis.
Jede Referenzlöschung, die einen Referenzzähler nicht auf $0$ fallen lässt, löst eine Überprüfung auf zyklische Referenzen aus, die potenziell viele Manipulationen von Referenzzählern mit sich bringt.
Im schlimmsten Fall wird dabei der gesamte Objektgraph drei Mal traversiert, ohne dass am Ende Speicher freigegeben wurde.
Der Algorithmus eignet sich daher eher für Fälle, in denen mehrere Referenzen auf ein Objekt selten sind, aber weniger für objektorientierte Konzepte (vgl. \cite[S. 215]{lins1992}).
Zyklische Referenzzählung kann somit unter Umständen wesentlich aufwendiger sein als naives Mark and Sweep.
Als Verbesserung hat Lins eine Variante vorgestellt, bei welcher die für eine zyklische Struktur infrage kommenden Objekte zunächst in eine Warteschlange eingefügt werden.
Die Überprüfung auf zyklische Referenzen wird damit erst bei Bedarf ausgelöst, etwa bei akutem Speichermangel oder voller Warteschlange.
Falls zuvor bereits die letzte Referenz auf ein Objekt entfernt wird, kann das Verfahren überspringen werden \cite{lins1992}.
Von Lin und Hou stammt darüber hinaus eine Variante, die mehrere zyklische Strukturen zu Teilgraphen eines Objektgraphen zusammenfasst.
Mittels einer einzigen Traversierung kann dann die Zahl der externen Referenzen dieses Teilgraphen bestimmt werden; existieren keine, so kann der gesamte Teilgraph -- und damit alle enthaltenen starken Zusammenhangskomponenten -- entsorgt werden \cite{linhou2006}.

\section{Optimierungsmöglichkeiten}
\label{sec:rc-optimizing}
Abschließend gehen wir auf zwei Ansätze ein, die eine Effizienzsteigerung der Referenzzählung bezwecken sollen.
Wir haben bereits festgestellt, dass Löschkaskaden, die durch freigegebene Objekte entstehen, zu unerwarteten Programmunterbrechungen führen können und die Buchhaltung jeder einzelnen Referenzmanipulation enormen Overhead erzeugt.
Von Deutsch und Bobrow stammt der Ansatz der \textit{verzögerten Referenzzählung} (engl. \textit{deferred reference counting}), der die Freigabe verwaister Objekte verzögert und auf eine Verfolgung von Referenzmanipulationen verzichtet, die in Feldern von Basisobjekten stattfinden \cite{deutsch1976}.
Der Referenzzähler eines Objekts wird dazu nicht im Header gespeichert.
Stattdessen werden zwei Tabellen -- die \textit{zero count table} \Var{ZCT} und die \textit{multi reference table} \Var{MRT} -- angelegt.
Erstere enthält alle Objekte, deren Referenzzähler $0$ ist.
Folglich werden diese nicht von anderen Objekten des Heaps referenziert, aber möglicherweise von Basisobjekten wie lokalen Variablen.
Die eingangs des Kapitels formulierte notwendige Bedingung in Lemma~\ref{lemma:notwendig-rc} ist damit außer Kraft gesetzt.
Die \Var{MRT} enthält wiederum alle Objekte, die mehrfach von Heapobjekten referenziert werden, und weist diesen ihre Referenzzähler zu, was etwa mit einer Hashtabelle realisiert werden kann.
Entsprechend wird ein Objekt genau einmal von einem Heapobjekt referenziert, wenn es sich weder in \Var{ZCT} noch \Var{MRT} befindet.

\begin{algorithm}[h]
\begin{algorithmic}[1]
	\State \MethodHead{writeRef}(\Var{obj}, \Var{i}, \Var{ref}):
	\State \quad \IF $\Var{obj} \notin \Roots$		\Comment{Schreibbarriere für Basisobjekte aussetzen}
	\State \quad \quad \Atomic
	\State \quad \quad \quad \IF (\Var{ref} $\neq$ \Null $\wedge$ \Var{*ref} $\neq$ \Var{obj})
	\State \quad \quad \quad \quad \Method{incRefCount}(\Var{*ref})
	\State \quad \quad \quad \IF (\Var{obj[i]} $\neq$ \Null $\wedge$ \Var{*obj[i]} $\neq$ \Var{obj})
	\State \quad \quad \quad \quad \Method{decRefCount}(\Var{*obj[i]})
	\State \quad \Var{obj[i]} $\gets$ \Var{ref}
	\Statex
	\State \MethodHead{incRefCount}(\Var{obj}):
	\State \quad \IF $\Var{obj} \in \Var{ZCT}$
	\State \quad \quad \Method{remove}(\Var{ZCT}, \Var{obj})	\Comment{Anzahl Referenzen ist $1$}
	\State \quad \ELSE \IF $\Var{obj} \in \Var{MRT}$
	\State \quad \quad $\Var{MRT}(\Var{obj}) \gets \Var{MRT}(\Var{obj}) + 1$	\Comment{Referenzzähler erhöhen}
	\State \quad \ELSE \Method{add}(\Var{MRT}, \Var{obj})		\Comment{Anzahl Referenzen ist $2$}
	\Statex
	\State \MethodHead{decRefCount}(\Var{obj}):
	\State \quad \IF $\Var{obj} \in \Var{MRT}$
	\State \quad \quad \IF $\Var{MRT}(\Var{obj}) > 2$
	\State \quad \quad \quad $\Var{MRT}(\Var{obj}) \gets \Var{MRT}(\Var{obj}) - 1$	\Comment{Referenzzähler erniedrigen}
	\State \quad \quad \ELSE \Method{remove}(\Var{MRT}, \Var{obj})	\Comment{Anzahl Referenzen ist $1$}
	\State \quad \ELSE \Method{add}(\Var{ZCT}, \Var{obj})			\Comment{Anzahl Referenzen ist $0$}
	\Statex
	\State \Atomic \MethodHead{collect}():
	\State \quad \FOREACH $\Var{ref} \in \Pointers(\Roots)$		\Comment{nicht gezählte Referenzen hinzufügen}
	\State \quad \quad \IF $\Var{ref} \neq \Null$
	\State \quad \quad \quad \Method{incRefCount}(\Var{*ref})
	\State \quad \FOREACH $\Var{obj} \in \Var{ZCT}$
	\State \quad \quad \FOREACH $\Var{ref} \in \Pointers(\Var{obj})$
	\State \quad \quad \quad \IF ($\Var{ref} \neq \Null \wedge \Var{*ref} \neq \Var{obj}$)
	\State \quad \quad \quad \quad \Method{decRefCount}(\Var{*ref})
	\State \quad \quad \Method{free}(\Var{obj})
	\State \quad \FOREACH $\Var{ref} \in \Pointers(\Roots)$		\Comment{vorige Anpassung korrigieren}
	\State \quad \quad \IF $\Var{ref} \neq \Null$
	\State \quad \quad \quad \Method{decRefCount}(\Var{*ref})
\end{algorithmic}
\caption[Verzögerte Referenzzählung nach Deutsch und Bobrow]{Verzögerte Referenzzählung nach Deutsch und Bobrow (vgl. \cite[S. 523f]{deutsch1976}).}
\label{algo:deferred-rc}
\end{algorithm}

Wird nun eine Referenz \Var{ref} in ein Feld \Var{obj[i]} geschrieben, kann der Schreibzugriff unsynchronisiert ausgeführt werden, wenn \Var{obj} ein Basisobjekt ist, da keine Referenzzähler angepasst werden (Zeile~2 in Algorithmus~\ref{algo:deferred-rc}).
Andernfalls sind mehrere Fälle zu unterscheiden:
Wird ein Referenzzähler eines Objekts \Var{obj} erhöht, das sich in \Var{ZCT} befindet (etwa, da es bislang nur von lokalen Variablen referenziert wird), so muss es aus \Var{ZCT} entfernt werden, da der Referenzzähler nun $1$ beträgt (Zeile~10f).
Ist es in der \Var{MRT}, so ist der zugehörige Referenzzähler $\Var{MRT}(\Var{obj})$ zu erhöhen (Zeile~12f).
Ist beides nicht der Fall, so muss \Var{obj} zur \Var{MRT} hinzugefügt werden; der Referenzzähler wird entsprechend mit $2$ initialisiert (Zeile~14).
Analoge Fallunterscheidungen sind nötig, wenn ein Referenzzähler reduziert wird (Zeile~16 bis 20).

Die Freigabe von Objekten kann nun zu geeigneten, unkritischen Zeitpunkten mittels der Prozedur \Method{collect} ausgelöst werden, sofern diese vorhersehbar sind, oder alternativ bei akutem Speichermangel.
Da die Objekte in der \Var{ZCT} gegebenenfalls noch von lokalen Variablen referenziert werden und nicht entfernt werden dürfen, müssen zunächst ihre Referenzzähler angepasst werden, indem über alle Referenzen von Basisobjekten iteriert wird (Zeile~22 bis 24).
Objekte, die im Anschluss in \Var{ZCT} verbleiben, sind tatsächlich verwaist und können bedenkenlos entfernt werden, ohne die Korrektheit des Algorithmus zu gefährden (Zeile~25 bis 29).

\begin{figure}[h]
	\centering
	\includestandalone{img/tikz/ch3-deferred}
	\caption[Veranschaulichung der verzögerten Referenzzählung]{Schema zur Veranschaulichung der verzögerten Referenzzählung.}
	\label{fig:rc-deferred}
\end{figure}

Abbildung~\ref{fig:rc-deferred} veranschaulicht die Arbeitsweise des Algorithmus und die Verschiebung eines Objekts \Var{obj} in bzw. aus \Var{ZCT} und \Var{MRT}.
Der maßgebliche Performancegewinn entsteht dadurch, dass Referenzmanipulationen in lokalen Variablen nicht unmmittelbar, sondern erst während einer Bereinigungsphase vermerkt werden.
Somit wirken sich die durch die Garbage Collection bedingten Schreibbarrieren nicht auf Berechnungen aus, die vorwiegend auf lokale Variablen zugreifen.
Dies kommt etwa Iterationen durch Datenstrukturen zu Gute.
Ein weiterer Vorteil ergibt sich für Anwendungen, in denen die meisten Objekte höchstens einmal referenziert werden und sich zu keinem Zeitpunkt in der \Var{MRT} befinden.
Für diese entfällt die Notwendigkeit, Referenzzähler zu hinterlegen und für die \Var{MRT} muss weniger Speicher reserviert werden, was den Speicherbedarf des gesamten Verfahrens reduziert.
Für Anwendungen, in denen diese Bedingung nicht zutrifft, ergibt sich jedoch die Problematik, die \Var{MRT} angemessen zu realisieren.
Im Falle einer Hashtabelle muss etwa eine geeignete Hashfunktion gewählt werden, um Schlüsselkollisionen und damit verbundene Performanceeinbußen zu vermeiden.\footnote{Kommt es zu vielen Schlüsselkollisionen, kann die Komplexität eines Zugriffs auf einen einzelnen Tabellenelement in $\oh(n)$ liegen, wobei $n$ die Anzahl der Einträge ist. Eine Vergrößerung der Schlüsselmenge zur Vermeidung von Kollisionen kann wiederum zu einem hohen Speicherbedarf führen, was den für den Heap zu Verfügung stehenden Speicher einschränkt (vgl. \cite[S. 253]{cormen-leiserson})}



\begin{algorithm}[h]
\begin{algorithmic}[1]
	\State \Atomic \MethodHead{writeRef}(\Var{obj}, \Var{i}, \Var{ref}):
	\State \quad \IF \NOT \Method{isModified}(\Var{\&obj[i]})
	\State \quad \quad \Method{addLog}(\Var{\&obj[i]}, \Var{obj[i]})	\Comment{Speichere alten Feldinhalt in Tabelle}
	\State \quad \quad \Method{setModified}(\Var{\&obj[i]})		\Comment{Markiere Feld als verändert}
	\State \quad $\Var{obj[i]} \gets \Var{ref}$
	\Statex
	\State \Atomic \MethodHead{processLog}():
	\State \quad \FOREACH $\Var{field} \in \Var{log}$
	\State \quad \quad \IF $\Var{*field} \neq \Var{log}(\Var{field})$	\Comment{Prüfe, ob Feldinhalt verändert wurde}
	\State \quad \quad \quad \IF ($\Var{*field} \neq \Null \wedge \Var{**field} \neq \Method{parent}(\Var{field})$)
	\State \quad \quad \quad \quad \Method{incRefCount}(\Var{**field})
	\State \quad \quad \quad \IF ($\Var{log}(\Var{field}) \neq \Null \wedge \Var{*log}(\Var{field}) \neq \Method{parent}(\Var{field})$)
	\State \quad \quad \quad \quad \Method{decRefCount}(\Var{*log}(\Var{field}))
	\State \quad \quad \Method{unsetModified}(\Var{field})
	\State \quad \quad \Method{removeLog}(\Var{field})		\Comment{Entferne Eintrag aus Tabelle}
	\State \quad \Method{collect}()
\end{algorithmic}
\caption[Aggregierte Referenzzählung nach Levanoni und Petrank]{Aggregierte Referenzzählung nach Levanoni und Petrank (vgl. \cite[S. 14ff]{levanoni2006}).}
\label{algo:coalesced-rc}
\end{algorithm}